# SmartFlow 前端开发文档

## 目录

- [1. 项目概述](#1-项目概述)
- [2. 技术栈](#2-技术栈)
- [3. 环境搭建](#3-环境搭建)
- [4. 项目架构](#4-项目架构)
- [5. UI/UX 设计规范](#5-uiux-设计规范)
- [6. 开发工作流](#6-开发工作流)
- [7. 状态管理](#7-状态管理)
- [8. 接口集成](#8-接口集成)
- [9. 测试规范](#9-测试规范)
- [10. 构建与发布](#10-构建与发布)
- [11. 常见问题](#11-常见问题)

## 1. 项目概述

SmartFlow是一款智能任务管理应用，提供AI任务拆解、智能日报分析、提醒系统和社群互动功能。前端使用Flutter框架开发，支持iOS和Android平台，与FastAPI后端进行交互。

### 1.1 主要功能

- 任务创建与管理
- AI任务自动拆解
- 智能日报生成与分析
- 提醒系统
- 用户社区互动
- 个人数据统计与分析

### 1.2 目标用户

- 项目管理人员
- 团队协作成员
- 个人任务管理用户
- 学习计划管理者

## 2. 技术栈

### 2.1 核心框架

- **Flutter**: 版本 3.19.0+
- **Dart**: 版本 3.3.0+

### 2.2 状态管理

- **Provider**: 轻量级状态管理，用于UI组件状态共享
- **Riverpod**: 高级状态管理，用于复杂业务逻辑

### 2.3 路由导航

- **go_router**: 声明式路由管理，支持嵌套路由和路由参数

### 2.4 网络请求

- **dio**: HTTP客户端，用于API调用
- **retrofit**: 类型安全的API调用
- **json_serializable**: JSON序列化/反序列化

### 2.5 本地存储

- **shared_preferences**: 键值对存储
- **sqflite**: SQLite数据库
- **hive**: NoSQL数据库

### 2.6 UI组件

- **flutter_svg**: SVG图标支持
- **cached_network_image**: 图片缓存
- **flutter_screenutil**: 屏幕适配
- **flutter_hooks**: 函数式组件开发

### 2.7 开发工具

- **VS Code / Android Studio**: 主要IDE
- **Flutter DevTools**: 性能分析
- **Figma**: UI设计工具

## 3. 环境搭建

### 3.1 Flutter环境配置

```bash
# 安装Flutter SDK
git clone https://github.com/flutter/flutter.git -b stable
export PATH="$PATH:`pwd`/flutter/bin"

# 验证安装
flutter doctor
```

### 3.2 项目初始化

```bash
# 克隆项目代码
git clone https://github.com/yourusername/SmartFlow-app.git
cd SmartFlow-app/smartflow_frontend

# 安装依赖
flutter pub get
```

### 3.3 编辑器配置

#### VS Code配置

安装以下插件:
- Flutter
- Dart
- Flutter Widget Snippets
- Awesome Flutter Snippets

#### Android Studio配置

安装Flutter和Dart插件。

### 3.4 运行项目

```bash
# 调试模式运行
flutter run

# 指定设备运行
flutter devices
flutter run -d <device_id>
```

## 4. 项目架构

### 4.1 目录结构

```
smartflow_frontend/
├── android/            # Android平台配置
├── ios/                # iOS平台配置
├── lib/
│   ├── main.dart       # 应用入口
│   ├── app.dart        # 应用根组件
│   ├── models/         # 数据模型
│   │   ├── task.dart
│   │   ├── user.dart
│   │   └── ...
│   ├── services/       # 服务层
│   │   ├── api_service.dart
│   │   ├── auth_service.dart
│   │   └── ...
│   ├── screens/        # 页面
│   │   ├── auth/
│   │   ├── tasks/
│   │   └── ...
│   ├── widgets/        # 可复用组件
│   │   ├── common/
│   │   ├── task/
│   │   └── ...
│   ├── providers/      # 状态管理
│   │   ├── auth_provider.dart
│   │   ├── task_provider.dart
│   │   └── ...
│   ├── utils/          # 工具函数
│   │   ├── constants.dart
│   │   ├── validators.dart
│   │   └── ...
│   └── theme/          # 主题配置
│       ├── colors.dart
│       ├── text_styles.dart
│       └── ...
├── assets/             # 静态资源
│   ├── images/
│   ├── icons/
│   └── fonts/
├── test/               # 测试代码
└── pubspec.yaml        # 项目配置
```

### 4.2 架构模式

本项目采用**分层架构**，主要分为:

1. **表现层(Presentation)**: 包括screens和widgets
2. **业务逻辑层(Business Logic)**: 包括providers
3. **数据层(Data)**: 包括models和services

### 4.3 设计模式

- **Repository Pattern**: 封装数据源
- **Provider Pattern**: 状态管理
- **Factory Pattern**: 创建对象
- **Singleton Pattern**: 单例服务

## 5. UI/UX 设计规范

### 5.1 设计资源

Figma设计文件位于: `prototypes/ui/page.figma.json`

### 5.2 色彩系统

```dart
// lib/theme/colors.dart
class AppColors {
  // 主色调
  static const Color primary = Color(0xFF3F51B5);
  static const Color secondary = Color(0xFF2196F3);
  
  // 文本颜色
  static const Color textPrimary = Color(0xFF212121);
  static const Color textSecondary = Color(0xFF757575);
  
  // 背景色
  static const Color background = Color(0xFFF5F5F5);
  
  // 任务状态颜色
  static const Color taskPending = Color(0xFFFFC107);
  static const Color taskInProgress = Color(0xFF03A9F4);
  static const Color taskCompleted = Color(0xFF4CAF50);
  static const Color taskDelayed = Color(0xFFF44336);
}
```

### 5.3 字体与排版

```dart
// lib/theme/text_styles.dart
class AppTextStyles {
  static const TextStyle heading1 = TextStyle(
    fontSize: 24,
    fontWeight: FontWeight.bold,
    color: AppColors.textPrimary,
  );
  
  static const TextStyle heading2 = TextStyle(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    color: AppColors.textPrimary,
  );
  
  static const TextStyle body = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );
  
  static const TextStyle caption = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.normal,
    color: AppColors.textSecondary,
  );
}
```

### 5.4 组件规范

#### 按钮

```dart
// lib/widgets/common/app_button.dart
class AppButton extends StatelessWidget {
  final String text;
  final VoidCallback onPressed;
  final bool isLoading;
  final bool isPrimary;
  
  const AppButton({
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.isPrimary = true,
  });
  
  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: isLoading ? null : onPressed,
      style: ElevatedButton.styleFrom(
        backgroundColor: isPrimary ? AppColors.primary : Colors.white,
        foregroundColor: isPrimary ? Colors.white : AppColors.primary,
        padding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
          side: isPrimary ? BorderSide.none : BorderSide(color: AppColors.primary),
        ),
      ),
      child: isLoading
          ? SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(
                  isPrimary ? Colors.white : AppColors.primary,
                ),
              ),
            )
          : Text(text),
    );
  }
}
```

#### 输入框

```dart
// lib/widgets/common/app_text_field.dart
class AppTextField extends StatelessWidget {
  final String label;
  final TextEditingController controller;
  final bool obscureText;
  final TextInputType keyboardType;
  final String? Function(String?)? validator;
  
  const AppTextField({
    required this.label,
    required this.controller,
    this.obscureText = false,
    this.keyboardType = TextInputType.text,
    this.validator,
  });
  
  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      keyboardType: keyboardType,
      validator: validator,
      decoration: InputDecoration(
        labelText: label,
        border: OutlineInputBorder(),
        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      ),
    );
  }
}
```

### 5.5 响应式设计

使用`flutter_screenutil`进行屏幕适配:

```dart
// 初始化
ScreenUtil.init(
  context,
  designSize: Size(375, 812), // 设计稿尺寸
);

// 使用
Container(
  width: 100.w, // 宽度适配
  height: 50.h, // 高度适配
  padding: EdgeInsets.all(10.r), // 内边距适配
  child: Text(
    'Hello',
    style: TextStyle(fontSize: 14.sp), // 字体大小适配
  ),
)
```

## 6. 开发工作流

### 6.1 功能开发流程

1. **需求分析**:
   - 了解功能需求和设计稿
   - 确认API接口规范

2. **模型定义**:
   - 创建数据模型类
   - 实现序列化/反序列化

3. **服务实现**:
   - 封装API调用
   - 处理错误情况

4. **状态管理**:
   - 创建Provider
   - 定义状态更新逻辑

5. **UI实现**:
   - 创建页面布局
   - 开发可复用组件
   - 连接状态与UI

6. **测试**:
   - 编写单元测试
   - 进行UI测试
   - 手动功能测试

### 6.2 Git工作流

参考项目[GitHub操作手册](./github操作手册.md)

### 6.3 代码规范

#### 命名规范

- **类名**: 大驼峰命名法 (TaskListScreen)
- **变量名/方法名**: 小驼峰命名法 (getUserData)
- **常量**: 大写下划线 (API_BASE_URL)
- **私有变量**: 下划线前缀 (_authToken)

#### 文件命名

- 全小写，下划线分隔 (task_list_screen.dart)
- 一个类一个文件，文件名与类名对应

#### 代码格式化

使用Flutter官方的`dart format`规范:

```bash
# 格式化单个文件
dart format lib/main.dart

# 格式化整个项目
dart format .
```

## 7. 状态管理

### 7.1 Provider模式

使用Provider包进行状态管理:

```dart
// lib/providers/task_provider.dart
class TaskProvider extends ChangeNotifier {
  final ApiService _apiService = ApiService();
  List<Task> _tasks = [];
  bool _isLoading = false;
  
  List<Task> get tasks => _tasks;
  bool get isLoading => _isLoading;
  
  Future<void> fetchTasks() async {
    _isLoading = true;
    notifyListeners();
    
    try {
      _tasks = await _apiService.getTasks();
    } catch (e) {
      // 错误处理
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  Future<void> addTask(Task task) async {
    _isLoading = true;
    notifyListeners();
    
    try {
      final newTask = await _apiService.createTask(task);
      _tasks.add(newTask);
    } catch (e) {
      // 错误处理
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}
```

### 7.2 全局状态配置

在应用根组件中配置Provider:

```dart
// lib/main.dart
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => AuthProvider()),
        ChangeNotifierProvider(create: (_) => TaskProvider()),
        ChangeNotifierProvider(create: (_) => ReportProvider()),
      ],
      child: MyApp(),
    ),
  );
}
```

### 7.3 在UI中使用状态

```dart
// lib/screens/tasks/task_list_screen.dart
class TaskListScreen extends StatefulWidget {
  @override
  _TaskListScreenState createState() => _TaskListScreenState();
}

class _TaskListScreenState extends State<TaskListScreen> {
  @override
  void initState() {
    super.initState();
    // 加载任务数据
    Future.microtask(() => 
      Provider.of<TaskProvider>(context, listen: false).fetchTasks()
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('我的任务')),
      body: Consumer<TaskProvider>(
        builder: (context, taskProvider, child) {
          if (taskProvider.isLoading) {
            return Center(child: CircularProgressIndicator());
          }
          
          if (taskProvider.tasks.isEmpty) {
            return Center(child: Text('暂无任务'));
          }
          
          return ListView.builder(
            itemCount: taskProvider.tasks.length,
            itemBuilder: (context, index) {
              final task = taskProvider.tasks[index];
              return TaskCard(task: task);
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => Navigator.pushNamed(context, '/tasks/create'),
        child: Icon(Icons.add),
      ),
    );
  }
}
```

## 8. 接口集成

### 8.1 API服务实现

```dart
// lib/services/api_service.dart
class ApiService {
  final Dio _dio = Dio();
  final String baseUrl = 'http://localhost:8000/api/v1';
  String? _authToken;
  
  ApiService() {
    _dio.options.baseUrl = baseUrl;
    _dio.options.connectTimeout = Duration(seconds: 5);
    _dio.options.receiveTimeout = Duration(seconds: 3);
    
    // 请求拦截器
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        if (_authToken != null) {
          options.headers['Authorization'] = 'Bearer $_authToken';
        }
        return handler.next(options);
      },
      onError: (DioError e, handler) {
        // 错误处理
        return handler.next(e);
      }
    ));
  }
  
  void setToken(String token) {
    _authToken = token;
  }
  
  void clearToken() {
    _authToken = null;
  }
  
  Future<dynamic> get(String endpoint) async {
    try {
      final response = await _dio.get(endpoint);
      return response.data;
    } catch (e) {
      _handleError(e);
    }
  }
  
  Future<dynamic> post(String endpoint, dynamic data) async {
    try {
      final response = await _dio.post(endpoint, data: data);
      return response.data;
    } catch (e) {
      _handleError(e);
    }
  }
  
  Future<List<Task>> getTasks() async {
    final response = await get('/tasks');
    return (response as List).map((json) => Task.fromJson(json)).toList();
  }
  
  Future<Task> createTask(Task task) async {
    final response = await post('/tasks', task.toJson());
    return Task.fromJson(response);
  }
  
  void _handleError(dynamic error) {
    if (error is DioError) {
      // 处理网络错误
      throw NetworkException(
        message: error.message,
        statusCode: error.response?.statusCode,
      );
    } else {
      // 处理其他错误
      throw Exception('未知错误: $error');
    }
  }
}
```

### 8.2 模型实现

```dart
// lib/models/task.dart
enum TaskPriority { low, medium, high, urgent }
enum TaskStatus { pending, inProgress, completed, delayed, cancelled }

class Task {
  final int? id;
  final String title;
  final String? description;
  final DateTime? dueDate;
  final TaskPriority priority;
  final TaskStatus status;
  final int? estimatedDuration;
  final double? importanceScore;
  final List<SubTask> subTasks;
  
  Task({
    this.id,
    required this.title,
    this.description,
    this.dueDate,
    this.priority = TaskPriority.medium,
    this.status = TaskStatus.pending,
    this.estimatedDuration,
    this.importanceScore,
    this.subTasks = const [],
  });
  
  factory Task.fromJson(Map<String, dynamic> json) {
    return Task(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      dueDate: json['due_date'] != null ? DateTime.parse(json['due_date']) : null,
      priority: _priorityFromString(json['priority']),
      status: _statusFromString(json['status']),
      estimatedDuration: json['estimated_duration'],
      importanceScore: json['importance_score'],
      subTasks: json['subtasks'] != null
          ? (json['subtasks'] as List).map((e) => SubTask.fromJson(e)).toList()
          : [],
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'due_date': dueDate?.toIso8601String(),
      'priority': priority.toString().split('.').last.toUpperCase(),
      'status': status.toString().split('.').last.toUpperCase(),
      'estimated_duration': estimatedDuration,
      'importance_score': importanceScore,
      'subtasks': subTasks.map((st) => st.toJson()).toList(),
    };
  }
  
  static TaskPriority _priorityFromString(String priority) {
    switch (priority) {
      case 'LOW': return TaskPriority.low;
      case 'MEDIUM': return TaskPriority.medium;
      case 'HIGH': return TaskPriority.high;
      case 'URGENT': return TaskPriority.urgent;
      default: return TaskPriority.medium;
    }
  }
  
  static TaskStatus _statusFromString(String status) {
    switch (status) {
      case 'PENDING': return TaskStatus.pending;
      case 'IN_PROGRESS': return TaskStatus.inProgress;
      case 'COMPLETED': return TaskStatus.completed;
      case 'DELAYED': return TaskStatus.delayed;
      case 'CANCELLED': return TaskStatus.cancelled;
      default: return TaskStatus.pending;
    }
  }
}

class SubTask {
  final int? id;
  final String title;
  final String? description;
  final TaskStatus status;
  final int order;
  
  SubTask({
    this.id,
    required this.title,
    this.description,
    this.status = TaskStatus.pending,
    this.order = 0,
  });
  
  factory SubTask.fromJson(Map<String, dynamic> json) {
    return SubTask(
      id: json['id'],
      title: json['title'],
      description: json['description'],
      status: Task._statusFromString(json['status']),
      order: json['order'] ?? 0,
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'title': title,
      'description': description,
      'status': status.toString().split('.').last.toUpperCase(),
      'order': order,
    };
  }
}
```

## 9. 测试规范

### 9.1 单元测试

```dart
// test/unit/task_model_test.dart
void main() {
  group('Task Model Tests', () {
    test('should create Task from JSON', () {
      final json = {
        'id': 1,
        'title': '完成报告',
        'description': '完成本周工作报告',
        'priority': 'HIGH',
        'status': 'PENDING',
      };
      
      final task = Task.fromJson(json);
      
      expect(task.id, 1);
      expect(task.title, '完成报告');
      expect(task.description, '完成本周工作报告');
      expect(task.priority, TaskPriority.high);
      expect(task.status, TaskStatus.pending);
    });
    
    test('should convert Task to JSON', () {
      final task = Task(
        id: 1,
        title: '完成报告',
        description: '完成本周工作报告',
        priority: TaskPriority.high,
      );
      
      final json = task.toJson();
      
      expect(json['id'], 1);
      expect(json['title'], '完成报告');
      expect(json['priority'], 'HIGH');
      expect(json['status'], 'PENDING');
    });
  });
}
```

### 9.2 组件测试

```dart
// test/widget/task_card_test.dart
void main() {
  testWidgets('TaskCard displays task information', (WidgetTester tester) async {
    final task = Task(
      id: 1,
      title: '完成报告',
      description: '完成本周工作报告',
      priority: TaskPriority.high,
    );
    
    await tester.pumpWidget(MaterialApp(
      home: Scaffold(body: TaskCard(task: task)),
    ));
    
    expect(find.text('完成报告'), findsOneWidget);
    expect(find.text('完成本周工作报告'), findsOneWidget);
    
    // 验证优先级标识
    expect(find.byIcon(Icons.flag), findsOneWidget);
  });
}
```

### 9.3 集成测试

```dart
// test/integration/login_flow_test.dart
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  
  testWidgets('Login and navigate to home screen', (WidgetTester tester) async {
    await tester.pumpWidget(MyApp());
    
    // 等待登录页加载
    await tester.pumpAndSettle();
    
    // 输入登录信息
    await tester.enterText(find.byType(TextField).at(0), 'test@example.com');
    await tester.enterText(find.byType(TextField).at(1), 'password');
    
    // 点击登录按钮
    await tester.tap(find.byType(ElevatedButton));
    await tester.pumpAndSettle();
    
    // 验证是否导航到主页
    expect(find.text('我的任务'), findsOneWidget);
  });
}
```

## 10. 构建与发布

### 10.1 调试构建

```bash
# 调试构建
flutter build apk --debug
flutter build ios --debug
```

### 10.2 发布构建

```bash
# Android发布
flutter build apk --release
flutter build appbundle --release

# iOS发布
flutter build ios --release
```

### 10.3 配置签名

#### Android签名

1. 创建密钥库:

```bash
keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key
```

2. 在`android/key.properties`中配置:

```
storePassword=<密码>
keyPassword=<密码>
keyAlias=key
storeFile=<密钥库位置>
```

3. 在`android/app/build.gradle`中配置:

```gradle
def keystoreProperties = new Properties()
def keystorePropertiesFile = rootProject.file('key.properties')
if (keystorePropertiesFile.exists()) {
    keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
}

android {
    // ...
    
    signingConfigs {
        release {
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null
            storePassword keystoreProperties['storePassword']
        }
    }
    buildTypes {
        release {
            signingConfig signingConfigs.release
        }
    }
}
```

#### iOS签名

通过Xcode处理签名和证书:

1. 打开`ios/Runner.xcworkspace`
2. 选择Target Runner
3. 在Signing & Capabilities中配置Team和Bundle Identifier

### 10.4 版本管理

在`pubspec.yaml`中管理版本:

```yaml
version: 1.0.0+1  # 格式: <version>+<build number>
```

## 11. 常见问题

### 11.1 性能优化

- 使用`const`构造函数减少不必要的重建
- 避免在`build`方法中执行耗时操作
- 使用`ListView.builder`替代`ListView`处理长列表
- 使用缓存图片组件如`CachedNetworkImage`
- 合理使用`FutureBuilder`和`StreamBuilder`

### 11.2 调试技巧

- 使用`debugPrint`输出调试信息
- 使用Flutter DevTools分析性能
- 使用`Placeholder`进行布局调试
- 使用`assert`进行条件检查

### 11.3 跨平台差异处理

```dart
// 平台检测
if (Platform.isAndroid) {
  // Android特定代码
} else if (Platform.isIOS) {
  // iOS特定代码
}

// 使用Platform Channel处理平台特定功能
const MethodChannel channel = MethodChannel('app.smartflow/native');
try {
  final result = await channel.invokeMethod('getPlatformVersion');
  platformVersion = result;
} on PlatformException catch (e) {
  platformVersion = 'Failed to get platform version: ${e.message}';
}
```

---

## 参考资源

- [Flutter官方文档](https://flutter.dev/docs)
- [Dart官方文档](https://dart.dev/guides)
- [Provider包文档](https://pub.dev/packages/provider)
- [Dio包文档](https://pub.dev/packages/dio)
- [Flutter测试文档](https://flutter.dev/docs/testing)
